#!/bin/bash
_CURRENT_FILE_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
_CURRENT_RUNNING_DIR="$( cd "$( dirname "." )" && pwd )"
STELLA_LOG_STATE="OFF"
. "${_CURRENT_FILE_DIR}"/stella-link.sh include

DEBUG="1"

DOCKER_COMPOSE_FILE_DEFAULT="${STELLA_APP_ROOT}/docker-compose.yml"
DOCKER_COMPOSE_FILE_GENERATED="${STELLA_APP_ROOT}/docker-compose-gen.yml"
ENV_FILE_DEFAULT="${STELLA_APP_ROOT}/env.default"
# ".env" file are auto loader by docker-compose
ENV_FILE_GENERATED="${STELLA_APP_ROOT}/.env"
ENV_FILE_FOR_BASH_GENERATED="${STELLA_APP_ROOT}/env.bash"
ENV_FILE_USER="${HOME}/mambo.env"


# MANAGE ENV VARIABLES AND FILES GENERATION -----------------


# update env files with current declared variables in VARIABLES_LIST
__update_env_files() {
	local __text="$1"
	echo "# ------ UPDATE : update_env_files : $(date) -- ${__text}" >> "${ENV_FILE_GENERATED}"
	echo "# ------ UPDATE : update_env_files : $(date) -- ${__text}" >> "${ENV_FILE_FOR_BASH_GENERATED}"
	for __variable in ${VARIABLES_LIST}; do
		[ -z ${!__variable+x} ] || echo "${__variable}=${!__variable}" >> "${ENV_FILE_GENERATED}"
		[ -z ${!__variable+x} ] || echo "${__variable}=\"${!__variable}\"" >> "${ENV_FILE_FOR_BASH_GENERATED}"		
	done
}

# add variables to variables list
__add_variables() {
	VARIABLES_LIST="${VARIABLES_LIST} $1"
}


# generate an env file to be uses as env-file in environment section of docker compose file (ENV_FILE_GENERATED)
__create_env_for_docker_compose() {
	echo "# ------ CREATE : create_env_for_docker_compose : $(date)" > "${ENV_FILE_GENERATED}"

	# combine user env file and default env file
	[ -f "${ENV_FILE_USER}" ] && cat <(echo \# --- PART FROM ${ENV_FILE_DEFAULT}) <(echo) <(echo) "${ENV_FILE_DEFAULT}" <(echo) <(echo \# --- PART FROM ${ENV_FILE_USER}) <(echo) <(echo) "${ENV_FILE_USER}" <(echo) >> "${ENV_FILE_GENERATED}" \
					|| cat <(echo \# --- PART FROM ${ENV_FILE_DEFAULT}) <(echo) <(echo) "${ENV_FILE_DEFAULT}" <(echo) <(echo \# --- PART FROM ${ENV_FILE_USER}) <(echo) <(echo) >> "${ENV_FILE_GENERATED}"

}

# generate an env file to be sourced (ENV_FILE_FOR_BASH_GENERATED)
__create_env_for_bash() {
	echo "# ------ CREATE : create_env_for_bash : $(date)" > "${ENV_FILE_FOR_BASH_GENERATED}"

	# combine user env file and default env file
	[ -f "${ENV_FILE_USER}" ] && cat <(echo \# --- PART FROM ${ENV_FILE_DEFAULT}) <(echo) <(echo) "${ENV_FILE_DEFAULT}" <(echo) <(echo \# --- PART FROM ${ENV_FILE_USER}) <(echo) <(echo) "${ENV_FILE_USER}" <(echo) >> "${ENV_FILE_FOR_BASH_GENERATED}" \
					|| cat <(echo \# --- PART FROM ${ENV_FILE_DEFAULT}) <(echo) <(echo) "${ENV_FILE_DEFAULT}" <(echo) <(echo \# --- PART FROM ${ENV_FILE_USER}) <(echo) <(echo) >> "${ENV_FILE_FOR_BASH_GENERATED}"

	# Preserve some variables like list
	sed -i 's/^MAMBO_MEDIA_FOLDERS=\(.*\)$/MAMBO_MEDIA_FOLDERS=\"\1\"/g' "${ENV_FILE_FOR_BASH_GENERATED}"
	sed -i 's/^MAMBO_DOMAIN=\(.*\)$/MAMBO_DOMAIN=\"\1\"/g' "${ENV_FILE_FOR_BASH_GENERATED}"
	sed -i 's/^MAMBO_MEDIA_SERVICES=\(.*\)$/MAMBO_MEDIA_SERVICES=\"\1\"/g' "${ENV_FILE_FOR_BASH_GENERATED}"
	sed -i 's/^MAMBO_SERVICES_AREA_MAIN=\(.*\)$/MAMBO_SERVICES_AREA_MAIN=\"\1\"/g' "${ENV_FILE_FOR_BASH_GENERATED}"
	sed -i 's/^MAMBO_SERVICES_AREA_SECONDARY=\(.*\)$/MAMBO_SERVICES_AREA_SECONDARY=\"\1\"/g' "${ENV_FILE_FOR_BASH_GENERATED}"
	sed -i 's/^MAMBO_SERVICES_AREA_ADMIN=\(.*\)$/MAMBO_SERVICES_AREA_ADMIN=\"\1\"/g' "${ENV_FILE_FOR_BASH_GENERATED}"
	sed -i 's/^MAMBO_SERVICES_REDIRECT_HTTPS=\(.*\)$/MAMBO_SERVICES_REDIRECT_HTTPS=\"\1\"/g' "${ENV_FILE_FOR_BASH_GENERATED}"
	sed -i 's/^LETS_ENCRYPT_SERVICES=\(.*\)$/LETS_ENCRYPT_SERVICES=\"\1\"/g' "${ENV_FILE_FOR_BASH_GENERATED}"
	sed -i 's/^MAMBO_SUBSERVICES=\(.*\)$/MAMBO_SUBSERVICES=\"\1\"/g' "${ENV_FILE_FOR_BASH_GENERATED}"
	sed -i 's/^MAMBO_ADDONS=\(.*\)$/MAMBO_ADDONS=\"\1\"/g' "${ENV_FILE_FOR_BASH_GENERATED}"

	# remove empty lines and commentaries
	#sed -i -e '/^[[:space:]]*$/d' -e '/^[#].*$/d' "${ENV_FILE_FOR_BASH_GENERATED}"

	# preserve existing setted variables - inherited from shell env
	#sed -i 's/^\(.*\)=\(.*\)$/\[ -z \"\${\1}\" \] \&\& \1=\2/g' "${ENV_FILE_FOR_BASH_GENERATED}"
}

# translate all relative path to absolute
# these path will overide variable defined in docker compse or env generated files because they are exported
__translate_all_path() {
	[ ! "${MAMBO_DATA_PATH}" = "" ] && export MAMBO_DATA_PATH="$($STELLA_API rel_to_abs_path "${MAMBO_DATA_PATH}" "${STELLA_APP_ROOT}")"
	[ ! "${MAMBO_DOWNLOAD_PATH}" = "" ] && export MAMBO_DOWNLOAD_PATH="$($STELLA_API rel_to_abs_path "${MAMBO_DOWNLOAD_PATH}" "${STELLA_APP_ROOT}")"
	[ ! "${PLEX_TRANSCODE_PATH}" = "" ] && export PLEX_TRANSCODE_PATH="$($STELLA_API rel_to_abs_path "${PLEX_TRANSCODE_PATH}" "${STELLA_APP_ROOT}")"
	

	if [ ! "${MAMBO_MEDIA_FOLDERS}" = "" ]; then
		__tmp=
		for f in ${MAMBO_MEDIA_FOLDERS}; do
			f="$($STELLA_API rel_to_abs_path "${f}" "${STELLA_APP_ROOT}")"
			__tmp="${__tmp} ${f}"
		done
		export MAMBO_MEDIA_FOLDERS="$($STELLA_API trim "${__tmp}")"
	fi
}

# generate docker compose file
__create_docker_compose_file() {
	rm -f "${DOCKER_COMPOSE_FILE_GENERATED}"

	# copy original docker compose file
	cp -f "${DOCKER_COMPOSE_FILE_DEFAULT}" "${DOCKER_COMPOSE_FILE_GENERATED}"

	__set_time_all
	__set_entrypoints_service_all
	__set_redirect_https_service_all
	__add_service_direct_port_access_all
	__set_gpu_all
	__add_volume_media_all
	__set_letsencrypt_service_all
}



# MANAGE FEATURES FOR ALL CONTAINTERS -----------------

# add gpu to all container that need its
__set_gpu_all() {
	[ ! "${PLEX_HARDWARE_TRANSCODE}" = "" ] && __add_gpu "plex" "${PLEX_HARDWARE_TRANSCODE}"
}

# set timezone to containers which need it
__set_time_all() {
	
	__add_volume_for_time "organizr2"
	__add_volume_for_time "ombi"
	__add_volume_for_time "sabnzbd"
	__add_volume_for_time "medusa"
	__add_volume_for_time "tautulli"
	__add_volume_for_time "traefik"
	__add_volume_for_time "web"
	__add_volume_for_time "jdownloader2"

	# service plex use TZ internal env var for time settings
	if [ -f "/etc/timezone" ]; then
		TZ="$(cat /etc/timezone)"
		yq w -i -- "${DOCKER_COMPOSE_FILE_GENERATED}" "services.plex.environment[+]" "TZ=${TZ}"
	fi
	
}



__set_letsencrypt_service_all() {

	
	case ${LETS_ENCRYPT} in
		enable|debug )
			for serv in ${LETS_ENCRYPT_SERVICES}; do
				__add_letsencrypt_service "${serv}"
				# add lets encrypt support for subservices
				for sub in ${MAMBO_SUBSERVICES}; do
					case $sub in
						$serv ) __add_letsencrypt_service "${sub}";;
					esac
				done
			done

			case ${LETS_ENCRYPT_CHALLENGE} in
				HTTP )
					yq w -i -- "${DOCKER_COMPOSE_FILE_GENERATED}" "services.traefik.command[+]" "--certificatesresolvers.mambo.acme.httpchallenge=true"
					yq w -i -- "${DOCKER_COMPOSE_FILE_GENERATED}" "services.traefik.command[+]" "--certificatesresolvers.mambo.acme.httpchallenge.entrypoint=web_main"
				;;
				DNS )
					yq w -i -- "${DOCKER_COMPOSE_FILE_GENERATED}" "services.traefik.command[+]" "--certificatesresolvers.mambo.acme.dnschallenge=true"
					yq w -i -- "${DOCKER_COMPOSE_FILE_GENERATED}" "services.traefik.command[+]" "--certificatesresolvers.mambo.acme.dnschallenge.provider=${LETS_ENCRYPT_CHALLENGE_DNS_PROVIDER}"
				;;
			esac
			
		;;
	esac

	# set letsencrypt debug server if needed
	[ "${LETS_ENCRYPT}" = "debug" ] && yq w -i -- "${DOCKER_COMPOSE_FILE_GENERATED}" "services.traefik.command[+]" "--certificatesresolvers.mambo.acme.caserver=${LETS_ENCRYPT_SERVER_DEBUG}"
}


__set_entrypoints_service_all() {
	for s in ${MAMBO_SERVICES_AREA_MAIN}; do
		__set_entrypoint_service "${s}"  "web_main"
	done
	for s in ${MAMBO_SERVICES_AREA_SECONDARY}; do
		__set_entrypoint_service "${s}"  "web_secondary"
	done
	for s in ${MAMBO_SERVICES_AREA_ADMIN}; do
		__set_entrypoint_service "${s}"  "web_admin"
	done
}

__set_redirect_https_service_all() {
	for s in ${MAMBO_SERVICES_REDIRECT_HTTPS}; do
		# look if on any entrypoint, we have to override the service router rule with the http-catchall rule
		for se in ${MAMBO_SERVICES_AREA_ADMIN}; do
			[ "${se}" = "${s}" ] && __set_redirect_https_service "${s}"  "web_admin"
		done
		for se in ${MAMBO_SERVICES_AREA_SECONDARY}; do
			[ "${se}" = "${s}" ] && __set_redirect_https_service "${s}"  "web_secondary"
		done
		for se in ${MAMBO_SERVICES_AREA_MAIN}; do
			[ "${se}" = "${s}" ] && __set_redirect_https_service "${s}"  "web_main"
		done
	done
}


__add_service_direct_port_access_all() {
	for service in $(compgen -A variable | grep _DIRECT_ACCESS_PORT); do
		port="${!service}"
		if [ ! "${port}" = "" ]; then
			service="${service%_DIRECT_ACCESS_PORT}"
			service="${service,,}"
			port_inside="$(yq r docker-compose.yml services.$service.expose[0])"
			if [ ! "${port_inside}" = "" ]; then
				[ "${VERBOSE}" = "1" ] && echo "* Activate direct access to $service : mapping $port to $port_inside"
				yq w -i -- "${DOCKER_COMPOSE_FILE_GENERATED}" "services.$service.ports[+]" "$port:$port_inside"
			else
				echo "* WARN : cannot activate direct access to $service through $port : Unknown inside port to map to. Inside port must be declared as first port in expose section."
			fi
		fi
	done
}


# add a media_xxx named volume defintion
# attach this media_xxx named volume to a /media/xxxx folder to each service listed in MAMBO_MEDIA_SERVICES
__add_volume_media_all() {
	for f in ${MAMBO_MEDIA_FOLDERS}; do
		f="$($STELLA_API rel_to_abs_path "${f}" "${STELLA_APP_ROOT}")"
		target="$(basename "${f}")"
		if [ -f "${f}" ]; then 
			echo "** [${f}] is a file, not mounted inside folder {/media}"
		else
			[ ! -d "${f}" ] && echo "** [${f}] is not an existing directory and will be auto created."
			__name="$($STELLA_API md5 "${f}")"
			__add_volume_local_definition "media_${__name}" "${f}"
			for s in $MAMBO_MEDIA_SERVICES; do
				__add_volume_mapping_service "${s}" "media_${__name}:/media/${target}"
			done
			[ "${VERBOSE}" = "1" ] && echo "** [${f}] will be mapped to {/media/${target}}"			
		fi
	done
}

# FEATURES MANAGEMENT --------
__add_gpu() {
	local __service="$1"
	local __opt="$2"

	__opt_intel_quicksync=0
	__opt_nvidia=0
	for o in $__opt; do
		[ "${o}" = "INTEL_QUICKSYNC" ] && __opt_intel_quicksync=1
		[ "${o}" = "NVIDIA" ] && __opt_nvidia=1
	done

	if [ "${__opt_intel_quicksync}" = "1" ]; then
		[ -d "/dev/dri" ] && yq w -i -- "${DOCKER_COMPOSE_FILE_GENERATED}" "services.${__service}.devices[+]" "/dev/dri:/dev/dri"
	fi

	if [ "${__opt_nvidia}" = "1" ]; then
		yq w -i -- "${DOCKER_COMPOSE_FILE_GENERATED}" "services.${__service}.environment[+]" "NVIDIA_VISIBLE_DEVICES=all"
		yq w -i -- "${DOCKER_COMPOSE_FILE_GENERATED}" "services.${__service}.environment[+]" "NVIDIA_DRIVER_CAPABILITIES=compute,video,utility"
		yq w -i -- "${DOCKER_COMPOSE_FILE_GENERATED}" "services.${__service}.runtime" "nvidia"
	fi
}

__add_volume_for_time() {
	local __service="$1"
	
	# create these volumes only if files exists
	[ -f "/etc/timezone" ] && __add_volume_mapping_service "${__service}" "/etc/timezone:/etc/timezone:ro"
	[ -f "/etc/localtime" ] && __add_volume_mapping_service "${__service}" "/etc/localtime:/etc/localtime:ro"
}


__add_letsencrypt_service() {
	local __service="$1"


	yq w -i -- "${DOCKER_COMPOSE_FILE_GENERATED}" "services.${__service}.labels[+]" "traefik.http.routers.${__service}-secure.tls.certresolver=mambo"
}

# declare an entrypoint to a service aswell to the secured version of the entrypoint
__set_entrypoint_service() {
	local __service="$1"
	local __entrypoint="$2"
	local __var="${__service^^}_ENTRYPOINTS"
	local __var_secure="${__service^^}_ENTRYPOINTS_SECURE"

	local __previous
	[ ! "${!__var}" = "" ] && __previous=",${!__var}"
	eval "export ${__var}=${__entrypoint}${__previous}"
	__add_variables "${__var}"

	__previous=
	[ ! "${!__var_secure}" = "" ] && __previous=",${!__var_secure}"
	eval "export ${__var_secure}=${__entrypoint}_secure${__previous}"
	__add_variables "${__var_secure}"
}

# change rule priority of a service to be overriden by the http-catchall rule
__set_redirect_https_service() {
	local __service="$1"
	
	__service="${__service^^}"
	local __var="${__service}_REDIRECT_HTTPS_PRIORITY"

	eval "export ${__var}=50"
	__add_variables "${__var}"

	# DEPRECATED : technique was to add a middleware redirect rule for each service
	# add only once ',' separator to compose file only if there is other middlewars declarated 
	# ex : "traefik.http.routers.sabnzbd.middlewares=${SABNZBD_REDIRECT_HTTPS}sabnzbd-stripprefix"
	# sed -i 's/\(.*\)\${'$__service'_REDIRECT_HTTPS}\([^,].\+\)\"$/\1\${'$__service'_REDIRECT_HTTPS},\2\"/g' "${DOCKER_COMPOSE_FILE_GENERATED}"

}

__add_volume_mapping_service() {
	local __service="$1"
	local __mapping="$2"

	yq w -i -- "${DOCKER_COMPOSE_FILE_GENERATED}" "services.${__service}.volumes[+]" "${__mapping}"

}

__add_volume_local_definition() {
	local __name="$1"
	local __path="$2"

	yq w -i -- "${DOCKER_COMPOSE_FILE_GENERATED}" "volumes.${__name}.driver" "local"
	yq w -i -- "${DOCKER_COMPOSE_FILE_GENERATED}" "volumes.${__name}.driver_opts.type" "none"
	yq w -i -- "${DOCKER_COMPOSE_FILE_GENERATED}" "volumes.${__name}.driver_opts.o" "bind"
	yq w -i -- "${DOCKER_COMPOSE_FILE_GENERATED}" "volumes.${__name}.driver_opts.device" "${__path}"
}




# PLEX -----------------

__init_service_plex() {
	# get claim token
	__claim_token=
	if [ "$(__is_plex_registered)" = "0" ]; then
		[ "${PLEX_USER}" = "" ] && echo "** Error missing plex user -- set PLEX_USER" && exit 1
		[ "${PLEX_PASSWORD}" = "" ] && echo "** Error missing plex password -- set PLEX_PASSWORD" && exit 1
		__auth_token="$(__get_plex_x_plex_auth_token ${PLEX_USER} ${PLEX_PASSWORD})"
		echo " ** From plex.tv -- get auth token : ${__auth_token}"
		__claim_token="$(__get_plex_claim_token "${__auth_token}")"
		echo " ** From plex.tv -- get claim token : ${__claim_token}"
		if [ "${__claim_token}" = "" ]; then
			echo "** Error while getting claim token"
			exit 1
		fi
	else
		echo "** Plex service is already registred"
	fi
	# if plex was already be claimed, PLEX_CLAIM env var passed to plex is ignored
	export PLEX_CLAIM="${__claim_token}"
	__add_variables "PLEX_CLAIM"

	# stop plex if it was already running
	docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" --project-directory "${STELLA_APP_ROOT}" stop plex
	# init plex
	docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" --project-directory "${STELLA_APP_ROOT}" up -d plex
	# wait for conf and db files created
	sleep 4
	docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" --project-directory "${STELLA_APP_ROOT}" stop plex
	sleep 4
	__set_plex_defaults
}

# test if plex was already claimed
__is_plex_registered() {
	PLEX_PREFERENCES_PATH="${MAMBO_DATA_PATH}/plex/Library/Application Support/Plex Media Server/Preferences.xml"
	[ -f "${PLEX_PREFERENCES_PATH}" ] && __online_token="$(__xml_get_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences/@PlexOnlineToken")"

	[ ${#__online_token} -gt 0 ] && echo "1" || echo "0"
}

# get a plex auth token
__get_plex_x_plex_auth_token() {
	local __login="$1"
	local __password="$2"

	__auth_token="$(curl -kLsu "${__login}":"${__password}" -X POST "https://plex.tv/users/sign_in.json" \
	-H "X-Plex-Version: 1.0.0" \
	-H "X-Plex-Product: Mambo" \
	-H "X-Plex-Client-Identifier: Mambo-$(__generate_machine_id)" \
	-H "Content-Type: application/x-www-form-urlencoded; charset=utf-8" | jq -r .user.authentication_token)"

	[ "${__auth_token}" = "null" ] && echo "" || echo "${__auth_token}"
}

# get plex claim token
__get_plex_claim_token() {
	local __x_plex_token="$1"

	__clam_token="$(curl -kLs -X GET "https://plex.tv/api/claim/token.json" \
		-H "X-Plex-Version: 1.0.0" \
		-H "X-Plex-Product: Mambo" \
		-H "X-Plex-Client-Identifier: Mambo-$(__generate_machine_id)" \
		-H "X-Plex-Token: ${__x_plex_token}" \
		-H "Content-Type: application/x-www-form-urlencoded; charset=utf-8" | jq -r .token)"


	[ "${__clam_token}" = "null" ] && echo "" || echo "${__clam_token}"

}


__set_plex_defaults() {
	PLEX_PREFERENCES_PATH="${MAMBO_DATA_PATH}/plex/Library/Application Support/Plex Media Server/Preferences.xml"
	
	
	if [ -f "${PLEX_PREFERENCES_PATH}" ]; then 
		# transcode folder to store temp files
		__xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "TranscoderTempDirectory" "/transcode"

		# 'forceAutoAdjustQuality' in Preferences.xml
		# Force clients to use automatic quality for media unless the quality is set higher than the quality of the video.
		# ex: quality set to 4mbps; watching >4mbps will trigger auto quality mode)
		# ex: quality set to original/max; auto quality will never be used & you will always be streaming at the video's original bitrate
		# default : 0
		__xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "forceAutoAdjustQuality" "${PLEX_CLIENT_FORCE_AUTO_QUALITY}"

		# 'AllowHighOutputBitrates' in Preferences.xml
		# Force transcode quality to upscale. But can cause high bandwidth usage for clients.
		# default : 0
		__xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "AllowHighOutputBitrates" "${PLEX_CLIENT_FORCE_TRANSCODE_UPSCALE}"

		# 'GdmEnabled' in Preferences.xml
		# This enables the media server to discover other servers and players on the local network.
		__xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "GdmEnabled" "0"

		# 'TranscoderThrottleBuffer' in Preferences.xml
		# Amount in seconds to buffer before throttling the transcoder.
		# default : 60
		__xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "TranscoderThrottleBuffer" "${PLEX_TRANSCODER_THROTTLE_BUFFER}"

		# ManualPortMappingMode="1" in Preferences.xml
		# default : 0
		# 'ManualPortMappingPort' in Preferences.xml
		# Manually specify public port. You may need to enable this to establish a direct connection from outside your network.
		# default : empty
		__xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "ManualPortMappingMode" "1"
		__xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "ManualPortMappingPort" "${MAMBO_PORT_MAIN}"

		#  TODO  secureConnections="1" customCertificateDomain="https://iron.studio-etrange.podzone.net:32400" customCertificateKey="mambo" customCertificatePath=" /var/lib/plexmediaserver/certificate.pfx"


		# 'DlnaEnabled' in Preferences.xml
		__xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "DlnaEnabled" "0"
		
		# collectUsageData in Preferences.xml
		# sendCrashReports in Preferences.xml
		__xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "collectUsageData" "0"
		__xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "sendCrashReports" "0"

		# secureConnections in Preferences.xml
		# 0 : Required
		# 1 : Preferred
		# 2 : Disabled
		__xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "secureConnections" "${PLEX_HTTPS_MODE}"


		# activate hardware transcoding
		[ ! "${PLEX_HARDWARE_TRANSCODE}" = "" ] && __xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "HardwareAcceleratedCodecs" "1" \
												|| __xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "HardwareAcceleratedCodecs" "0" \

	fi

	# optimize plex db
	[ ! "${PLEX_DB_CACHE_SIZE}" = "" ] && __set_plex_db_cache_size "${PLEX_DB_CACHE_SIZE}"

}



# optimize plex db
# could ameliorate some result
# https://github.com/Cloudbox/Cloudbox/blob/master/roles/plex/tasks/subtasks/settings/db_cache_size.yml
# https://forums.plex.tv/t/plex-library-performance-tip/176195/10
__set_plex_db_cache_size() {
	if [ ! "$1" = "" ]; then
		PLEX_DATABASE_SUBPATH="Library/Application Support/Plex Media Server/Plug-in Support/Databases/com.plexapp.plugins.library.db"
		# set default_cache_size
		if [ -f "${MAMBO_DATA_PATH}/plex/${PLEX_DATABASE_SUBPATH}" ]; then

			docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" stop plex

			echo "** Actual plex db default_cache_size :"
			docker run --rm -v "${MAMBO_DATA_PATH}/plex:/data" nouchka/sqlite3 "/data/${PLEX_DATABASE_SUBPATH}" "PRAGMA default_cache_size;"
			echo "** Set plex db default_cache_size to $1"
			docker run --rm -v "${MAMBO_DATA_PATH}/plex:/data" nouchka/sqlite3 "/data/${PLEX_DATABASE_SUBPATH}" "PRAGMA default_cache_size=$1;"
			echo "** Actual plex db default_cache_size :"
			docker run --rm -v "${MAMBO_DATA_PATH}/plex:/data" nouchka/sqlite3 "/data/${PLEX_DATABASE_SUBPATH}" "PRAGMA default_cache_size;"
		else
			echo "[${MAMBO_DATA_PATH}/plex/${PLEX_DATABASE_SUBPATH}] do not exist"
			echo "Plex database do not exist yet, launch at least once plex."
		fi
	fi
}



# VARIOUS -----------------

__get_variable_names() {
	local __file="$1"
	sed -e '/^[[:space:]]*$/d' -e '/^[#].*$/d' -e 's/^\(.*\)=\(.*\)$/\1/g' "${__file}"
}


# set an attribute value of a node selected by an xpath expression
# 	__xml_replace_attribute_value "Preferences.xml" "/Preferences" "Preferences" "TranscoderTempDirectory" "/transode"
# 	xidel Preferences.xml --silent --xml --xquery3 'let $selected := /Preferences return transform(/,function($e) { if ($selected[$e is .]) then <Preferences>{$e/attribute() except $e/@TranscoderTempDirectory, attribute TranscoderTempDirectory { "/transcode" },$e/node()}</Preferences> else $e })'
# http://x-query.com/pipermail/talk/2013-December/004266.html
__xml_set_attribute_value() {
	local __file="$1"
	local __xpath_selector="$2"
	local __node_name="$3"
	local __attribute_name="$4"
	local __attribute_value="$5"


	xidel "${__file}" --silent --xml --xquery3 'let $selected := '${__xpath_selector}' return transform(/,function($e) { if ($selected[$e is .]) then <'${__node_name}'>{$e/attribute() except $e/@'${__attribute_name}', attribute '${__attribute_name}' { "'${__attribute_value}'" },$e/node()}</'${__node_name}'> else $e })' > "${__file}.new"
	rm -f "${__file}"
	mv "${__file}.new" "${__file}"
}

__xml_get_attribute_value() {
	local __file="$1"
	local __xpath_selector="$2"

	xidel "${__file}" --silent --extract "${__xpath_selector}"
}


# mambo mandatory root paths
__set_mandatory_root_path_to_default() {
	if [ "${DEFAULT_HARDCODED_MAMBO_DATA_PATH}" = "1" ]; then
		 # TODO 1 chown ${MAMBO_USER_ID}:${MAMBO_GROUP_ID} "${MAMBO_DATA_PATH}" ? if exists ? or do it in service_init ?
		 # TODO 2 create dir in all cases ? not only in case we are using default values
		docker run -it --rm -v "${STELLA_APP_WORK_ROOT}":"${STELLA_APP_WORK_ROOT}" bash:4.4.23 bash -c "mkdir -p "${MAMBO_DATA_PATH}" && chown ${MAMBO_USER_ID}:${MAMBO_GROUP_ID} "${MAMBO_DATA_PATH}""
	fi
	if [ "${DEFAULT_HARDCODED_MAMBO_DOWNLOAD_PATH}" = "1" ]; then
		docker run -it --rm -v "${STELLA_APP_WORK_ROOT}":"${STELLA_APP_WORK_ROOT}" bash:4.4.23 bash -c "mkdir -p "${MAMBO_DOWNLOAD_PATH}" && chown ${MAMBO_USER_ID}:${MAMBO_GROUP_ID} "${MAMBO_DOWNLOAD_PATH}""
	fi
}


# test if mandatory root paths exists
__check_mandatory_root_path() {
	[ ! -d "${MAMBO_DATA_PATH}" ] && echo "* ERROR : Mandatory data root path [${MAMBO_DATA_PATH}] do not exist" && exit 1
	[ ! -d "${MAMBO_DOWNLOAD_PATH}" ] && echo "* ERROR : Mandatory download root path [${MAMBO_DOWNLOAD_PATH}] do not exist" && exit 1
	if [ "${MAMBO_MEDIA_FOLDERS}" = "" ]; then
		echo "* WARN : There is no media folders defined"
	else
		for f in ${MAMBO_MEDIA_FOLDERS}; do
			[ ! -d "${f}" ] && echo "* ERROR : Mandatory declared media folder [${f}] do not exist" && exit 1
		done
	fi
}

__check_lets_encrypt_settings() {
 	case ${LETS_ENCRYPT} in
    	enable|debug ) 
			[ "${LETS_ENCRYPT_MAIL}" = "" ] && echo "* ERROR : you have to specify a mail as identity into LETS_ENCRYPT_MAIL variable when using let's encrypt." && exit 1
			[ "${MAMBO_DOMAIN}" = '.*' ] && echo "* ERROR : you cannot use a generic domain (.*) setted by MAMBO_DOMAIN when using let's encrypt. Set MAMBO_DOMAIN variables or --domain comand line option with other value." && exit 1
			[ "${MAMBO_DOMAIN}" = "" ] && echo "* ERROR : you have to set a domain with MAMBO_DOMAIN variable or --domain comand line option when using let's encrypt." && exit 1
			[ ! "${MAMBO_PORT_MAIN}" = "80" ] && echo "* ERROR : main area network HTTP port is not 80 but ${MAMBO_PORT_MAIN}. You need to use DNS challenge for let's encrypt. Set LETS_ENCRYPT_CHALLENGE* variables." && exit 1
			[ ! "${MAMBO_PORT_MAIN_SECURE}" = "443" ] && echo "* ERROR : main area network HTTPS port is not 443 ${MAMBO_PORT_MAIN_SECURE}. You need to use DNS challenge for let's encrypt. Set LETS_ENCRYPT_CHALLENGE* variables" && exit 1
		;;
	esac
}

usage() {
	echo "USAGE :"
	echo "----------------"
	echo "o-- general management :"
	echo "L     install : deploy this app"
	echo "L     init [plex|addons] [--claim] : init services & addons. Do it once before launch. - will stop plex --claim : will force to claim server even it is already registred TODO"
	echo "L     up [service [-d]] : launch all mambo services or one service"
	echo "L     down [service] : down all mambo services or one service"
	echo "L     restart [service [-d]] : restart all mambo services or one service"
	echo "L     info [plex]: give info on Mambo. Will generate conf files and print configuration used when launching any service."
	echo "L     status [service] : see status"
	echo "L     logs [service] : see logs"
	echo "L     shell <service> : launch a shell into a running service"
	
}

# COMMAND LINE -----------------------------------------------------------------------------------
PARAMETERS="
ACTION=											'action' 			a				'info shell up down status install logs init restart' '1'
TARGET=												'target' 					a				'jdownloader2 addons traefik organizr2 ombi sabnzbd plex medusa tautulli web'	'0'
"
OPTIONS="
DOMAIN='' 					'' 				'domain'				s 			0			''		  Mambo domain name.
FILE='${ENV_FILE_USER}'				  		'f'				'path'					s			0		''					  User env site file (example : HOME/mambo.env).
DEBUG='' 					'' 				''				b 			0			''		  Debug mode. More verbose and use lets encrypt debug server to not reach rate limit.
VERBOSE=''				    'v'				''						b			0		''					  Verbose mode for debug purpose.
DAEMON=''				    'd'				''						b			0		''					  Daemon mode. When launching whole mambo, it is in daemon mode by default, but when launching a specific service, launch it in daemon mode.
PUID='' 			'u' 			'string'				s 			0			''		  user id - set MAMBO_USER_ID variable - will own bind mount created folder/files - Default current user group $(id -u).
PGID='' 			'g' 			'string'				s 			0			''		  group id - set MAMBO_GROUP_ID variable - will own bind mount created folder/files - Default current user group $(id -g).
"
$STELLA_API argparse "$0" "$OPTIONS" "$PARAMETERS" "$STELLA_APP_NAME" "$(usage)" "EXTRA_PARAMETER ARG" "$@"

#-------------------------------------------------------------------------------------------
ENV_FILE_USER="$($STELLA_API rel_to_abs_path "${FILE}" "${_CURRENT_RUNNING_DIR}")"
[ "${DAEMON}" = "1" ] && DAEMON="-d"
if [ "${DEBUG}" = "1" ]; then
	VERBOSE="1"
	DOCKER_COMPOSE_LOG="--verbose"
fi


# check if mambo have been installed and generate all conf files
type docker-compose 1>/dev/null 2>&1 && {

	# NOTE variable resolution priority
	#	1.command line
	#	2.shell env variables
	# 	3.user env file
	# 	4.default env file
	# 	5.default values hardcoded in mambo

	# variables list
	VARIABLES_LIST="$(__get_variable_names "${ENV_FILE_DEFAULT}")"

	# generate env files
	__create_env_for_docker_compose
	__create_env_for_bash

	# set some environment variables created at runtime
	export MAMBO_HOST_IP="${STELLA_HOST_IP}"
	__add_variables "MAMBO_HOST_IP"
	export MAMBO_HOST_DEFAULT_IP="${STELLA_HOST_DEFAULT_IP}"
	__add_variables "MAMBO_HOST_DEFAULT_IP"
	export MAMBO_HOSTNAME="$(hostname)"
	__add_variables "MAMBO_HOSTNAME"
	export MAMBO_EXTERNAL_IP="$(curl -s ipinfo.io/ip)"
	__add_variables "MAMBO_EXTERNAL_IP"

	

	# update env files with current setted variables values
	# so priority here become :
	#	- shell env variables
	# 	- user env file
	# 	- default env file
	__update_env_files "ingest variables from shell env and created/modified ones"

	# load variables 
	# so priority here become :
	#	- shell env variables
	# 	- user env file
	# 	- default env file
	. "${ENV_FILE_FOR_BASH_GENERATED}"

	# set environment variables from command line
	# so priority here become :
	#	- command line
	#	- shell env variables
	# 	- user env file
	# 	- default env file
	[ ! "${PUID}" = "" ] && export MAMBO_USER_ID="${PUID}"
	[ ! "${PGID}" = "" ] && export MAMBO_GROUP_ID="${PGID}"
	[ ! "${DOMAIN}" = "" ] && export MAMBO_DOMAIN="${DOMAIN}"
	if [ "${DEBUG}" = "1" ]; then
		[ "${LETS_ENCRYPT}" = "enable" ] && export LETS_ENCRYPT="debug"
	fi

	# set environment variables with hardcoded default values
	# so priority here become :
	#	- command line
	#	- shell env variables
	# 	- user env file
	# 	- default env file
	# 	- default values hardcoded in mambo
	[ "${MAMBO_USER_ID}" = "" ] && export MAMBO_USER_ID="$(id -u)"
	[ "${MAMBO_GROUP_ID}" = "" ] && export MAMBO_GROUP_ID="$(id -g)"
	[ "${MAMBO_DATA_PATH}" = "" ] && DEFAULT_HARDCODED_MAMBO_DATA_PATH="1" && export MAMBO_DATA_PATH="${STELLA_APP_WORK_ROOT}/data"
	[ "${MAMBO_DOWNLOAD_PATH}" = "" ] && DEFAULT_HARDCODED_MAMBO_DOWNLOAD_PATH="1" && export MAMBO_DOWNLOAD_PATH="${STELLA_APP_WORK_ROOT}/download"


	case ${ACTION} in
		info|up|restart )
			[ "$(__check_tcp_port_open "${MAMBO_EXTERNAL_IP}" "${MAMBO_PORT_MAIN}")" = "TRUE" ] && export MAMBO_PORT_MAIN_REACHABLE=1
			__add_variables "MAMBO_PORT_MAIN_REACHABLE"
			[ "$(__check_tcp_port_open "${MAMBO_EXTERNAL_IP}" "${MAMBO_PORT_MAIN_SECURE}")" = "TRUE" ] && export MAMBO_PORT_MAIN_SECURE_REACHABLE=1
			__add_variables "MAMBO_PORT_MAIN_SECURE_REACHABLE"
			[ "$(__check_tcp_port_open "${MAMBO_EXTERNAL_IP}" "${MAMBO_PORT_SECONDARY}")" = "TRUE" ] && export MAMBO_PORT_SECONDARY_REACHABLE=1
			__add_variables "MAMBO_PORT_SECONDARY_REACHABLE"
			[ "$(__check_tcp_port_open "${MAMBO_EXTERNAL_IP}" "${MAMBO_PORT_SECONDARY_SECURE}")" = "TRUE" ] && export MAMBO_PORT_SECONDARY_SECURE_REACHABLE=1
			__add_variables "MAMBO_PORT_SECONDARY_SECURE_REACHABLE"
			[ "$(__check_tcp_port_open "${MAMBO_EXTERNAL_IP}" "${MAMBO_PORT_ADMIN}")" = "TRUE" ] && export MAMBO_PORT_ADMIN_REACHABLE=1
			__add_variables "MAMBO_PORT_ADMIN_REACHABLE"
			[ "$(__check_tcp_port_open "${MAMBO_EXTERNAL_IP}" "${MAMBO_PORT_ADMIN_SECURE}")" = "TRUE" ] && export MAMBO_PORT_ADMIN_SECURE_REACHABLE=1
			__add_variables "MAMBO_PORT_ADMIN_SECURE_REACHABLE"
		;;
	esac

	# update some loaded variables
	__translate_all_path

	# generate compose file - add some new variables to VARIABLES_LIST
	__create_docker_compose_file

	# update env files with current variables values
	# so priority here become :
	#	- command line
	#	- shell env variables
	# 	- user env file
	# 	- default env file
	# 	- default values hardcoded in mambo
	__update_env_files "ingest variables from command line and created/modified ones"
	# load variables 
	# so priority here become :
	#	- command line
	#	- shell env variables
	# 	- user env file
	# 	- default env file
	# 	- default values hardcoded in mambo
	. "${ENV_FILE_FOR_BASH_GENERATED}"

} || {
	if [ ! "${ACTION}" = "install" ]; then
		echo "** ERROR : please install app first"
		exit 1
	fi
}




case ${ACTION} in
	install )
		;;
	up|restart )
		__set_mandatory_root_path_to_default
		__check_mandatory_root_path
		__check_lets_encrypt_settings
		;;
	* )
		__set_mandatory_root_path_to_default
		__check_mandatory_root_path
		;;
esac


# ------------- ENV ----------------------------


case $ACTION in
	install )
		echo "** Install requirements"
		$STELLA_API get_features
	;;

	shell )
		if [ "${TARGET}" = "" ]; then
			echo "** ERROR : specify a running service in which you want a shell access"
			exit 1
		else
			docker exec -it "mambo_${TARGET}" /bin/sh -c "[ -e /bin/bash ] && /bin/bash || /bin/sh"
		fi
	;;

	init )
		
		case ${TARGET} in
			plex )
				echo "** Init service Plex"
				__init_service_plex
				;;
			addons )
				echo "** Init service Mambo addons"
				docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" --project-name mambo --project-directory "${STELLA_APP_ROOT}" up addons
				;;
			* )
				echo "** Init service Plex"
				__init_service_plex
				echo "** Init service Mambo addons"
				docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" --project-name mambo --project-directory "${STELLA_APP_ROOT}" up addons
				;;
		esac
	;;

	info )
		case "${TARGET}" in
			plex )
				echo "---------==---- PLEX ----==---------"
				[ "${PLEX_USER}" = "" ] && echo "** Error missing plex user -- set PLEX_USER" && exit 1
				[ "${PLEX_PASSWORD}" = "" ] && echo "** Error missing plex password -- set PLEX_PASSWORD" && exit 1
				echo "L-- X-Plex-Token : $(__get_plex_x_plex_auth_token "${PLEX_USER}" "${PLEX_PASSWORD}")"
			;;
			* )
			docker-compose ${DOCKER_COMPOSE_LOG} -f "${DOCKER_COMPOSE_FILE_GENERATED}" --project-name mambo --project-directory "${STELLA_APP_ROOT}" up service_init
			;;
		esac
		

		
	;;

	up )
		# NOTE we need to specify project directory because when launching from an other directory, docker compose seems to NOT auto load .env file
		docker-compose ${DOCKER_COMPOSE_LOG} -f "${DOCKER_COMPOSE_FILE_GENERATED}" --project-name mambo --project-directory "${STELLA_APP_ROOT}" up ${DAEMON} ${TARGET:-mambo}
		if [ "${DAEMON}" = "" ]; then
			[ "${TARGET}" = "" ] && docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" --project-name mambo --project-directory "${STELLA_APP_ROOT}" logs service_init
		else
			docker-compose ${DOCKER_COMPOSE_LOG} -f "${DOCKER_COMPOSE_FILE_GENERATED}" --project-name mambo --project-directory "${STELLA_APP_ROOT}" logs service_init
		fi
	;;

	down )
		case "${TARGET}" in
			"") 
				docker-compose ${DOCKER_COMPOSE_LOG} -f "${DOCKER_COMPOSE_FILE_GENERATED}" --project-name mambo --project-directory "${STELLA_APP_ROOT}" down -v 
			;;
			*) 
				docker-compose ${DOCKER_COMPOSE_LOG} -f "${DOCKER_COMPOSE_FILE_GENERATED}" --project-name mambo --project-directory "${STELLA_APP_ROOT}" stop ${TARGET}
			;;
		esac
	;;

	restart )
		case "${TARGET}" in
		"") 
			docker-compose ${DOCKER_COMPOSE_LOG} -f "${DOCKER_COMPOSE_FILE_GENERATED}" --project-name mambo --project-directory "${STELLA_APP_ROOT}" down -v 
		;;
		*) 
			docker-compose ${DOCKER_COMPOSE_LOG} -f "${DOCKER_COMPOSE_FILE_GENERATED}" --project-name mambo --project-directory "${STELLA_APP_ROOT}" stop ${TARGET}
		;;
		esac
		docker-compose ${DOCKER_COMPOSE_LOG} -f "${DOCKER_COMPOSE_FILE_GENERATED}" --project-name mambo --project-directory "${STELLA_APP_ROOT}" up ${DAEMON} ${TARGET:-mambo}
		if [ "${DAEMON}" = "" ]; then
			[ "${TARGET}" = "" ] && docker-compose ${DOCKER_COMPOSE_LOG} -f "${DOCKER_COMPOSE_FILE_GENERATED}" --project-name mambo --project-directory "${STELLA_APP_ROOT}" logs service_init
		else
			docker-compose ${DOCKER_COMPOSE_LOG} -f "${DOCKER_COMPOSE_FILE_GENERATED}" --project-name mambo --project-directory "${STELLA_APP_ROOT}" logs service_init
		fi

	;;

	status )
		docker-compose ${DOCKER_COMPOSE_LOG} -f "${DOCKER_COMPOSE_FILE_GENERATED}" --project-name mambo --project-directory "${STELLA_APP_ROOT}" ps ${TARGET}
	;;

	logs )
		docker-compose ${DOCKER_COMPOSE_LOG} -f "${DOCKER_COMPOSE_FILE_GENERATED}" --project-name mambo --project-directory "${STELLA_APP_ROOT}" logs -t ${TARGET}
	;;
esac


