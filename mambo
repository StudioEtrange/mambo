#!/bin/bash
_CURRENT_FILE_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
_CURRENT_RUNNING_DIR="$( cd "$( dirname "." )" && pwd )"
. "${_CURRENT_FILE_DIR}"/stella-link.sh include

DEBUG="1"

DOCKER_COMPOSE_FILE_DEFAULT="${STELLA_APP_ROOT}/docker-compose.yml"
DOCKER_COMPOSE_FILE_GENERATED="${STELLA_APP_ROOT}/docker-compose-gen.yml"
ENV_FILE_DEFAULT="${STELLA_APP_ROOT}/env.default"
# ".env" file are auto loader by docker-compose
ENV_FILE_GENERATED="${STELLA_APP_ROOT}/.env"
ENV_FILE_FOR_BASH_GENERATED="${STELLA_APP_ROOT}/env.bash"
ENV_FILE_USER="${HOME}/mambo.env"

# List of all services embedded that can be manipulated 
MAMBO_SERVICES_LIST="traefik organizr2 ombi sabnzbd plex medusa tautulli"

# MANAGE ENV VARIABLES AND FILES GENERATION -----------------
__manage_env_and_files() {
	__create_env_for_docker_compose
	__set_env_for_bash
	__translate_all_path
	__set_docker_compose_file
	__set_letsencrypt_variable
}


# Let's encryot HTTP Challenge is used
# HTTP Challenge needs to access ports 80 & 443
# https://docs.traefik.io/user-guides/docker-compose/acme-http/
# traefik use EXPOSED ports 80 & 443 so from inside traefik container, not the mapped one
__set_letsencrypt_variable() {
	local __opt="$1"

	__opt_debug=0
	for o in $__opt; do
		[ "${o}" = "DEBUG" ] && __opt_debug=1
	done
	
	# https://docs.traefik.io/reference/static-configuration/env/


	export TRAEFIK_CERTIFICATESRESOLVERS_MAMBO="true"
	__update_env_for_docker_compose "TRAEFIK_CERTIFICATESRESOLVERS__MAMBO"
	export TRAEFIK_CERTIFICATESRESOLVERS_MAMBO_ACME_HTTPCHALLENGE="true"
	__update_env_for_docker_compose "TRAEFIK_CERTIFICATESRESOLVERS__MAMBO__ACME_HTTPCHALLENGE"
	export TRAEFIK_CERTIFICATESRESOLVERS_MAMBO_ACME_HTTPCHALLENGE_ENTRYPOINT="web_main"
	__update_env_for_docker_compose "TRAEFIK_CERTIFICATESRESOLVERS__MAMBO__ACME_HTTPCHALLENGE_ENTRYPOINT"
	[ "${DEBUG}" = "1" ] && export TRAEFIK_CERTIFICATESRESOLVERS_MAMBO_ACME_CASERVER="${LETS_ENCRYPT_SERVER_DEBUG}" && __update_env_for_docker_compose "TRAEFIK_CERTIFICATESRESOLVERS_MAMBO_ACME_CASERVER"
	export TRAEFIK_CERTIFICATESRESOLVERS_MAMBO_ACME_EMAIL="${LETS_ENCRYPT_MAIL}"
	__update_env_for_docker_compose "TRAEFIK_CERTIFICATESRESOLVERS__MAMBO__ACME_EMAIL"
	export TRAEFIK_CERTIFICATESRESOLVERS_MAMBO_ACME_STORAGE="/letsencrypt/acme.json"
	__update_env_for_docker_compose "TRAEFIK_CERTIFICATESRESOLVERS__MAMBO__ACME_STORAGE"
 
}


# generate an env file to be uses as env-file in environment section of docker compose file (ENV_FILE_GENERATED)
__create_env_for_docker_compose() {
	[ -f "${ENV_FILE_USER}" ] && cat "${ENV_FILE_DEFAULT}" <(echo) "${ENV_FILE_USER}" <(echo) > "${ENV_FILE_GENERATED}" \
					|| cat "${ENV_FILE_DEFAULT}" <(echo) > "${ENV_FILE_GENERATED}"

}

# exporting variable is not enough to have access to its value into a bash shell into a container
# export a var is enough for docker compose to use its value and replace occurences in compose file
# we have to explicity add variable in env-file
__update_env_for_docker_compose() {
	local __variable="$1"

	echo "${__variable}=${!__variable}" >> "${ENV_FILE_GENERATED}"
}

# generate an env file to be sourced (ENV_FILE_FOR_BASH_GENERATED)
__set_env_for_bash() {
	# Make '.env' docker-compose-file compatible for bash
	sed -e 's/^MAMBO_MEDIA_FOLDERS=\(.*\)$/MAMBO_MEDIA_FOLDERS=\"\1\"/g' "${ENV_FILE_GENERATED}" > "${ENV_FILE_FOR_BASH_GENERATED}"
	sed -i 's/^MAMBO_MEDIA_SERVICES=\(.*\)$/MAMBO_MEDIA_SERVICES=\"\1\"/g' "${ENV_FILE_FOR_BASH_GENERATED}"
	sed -i 's/^MAMBO_SERVICES_ENTRYPOINT_MAIN=\(.*\)$/MAMBO_SERVICES_ENTRYPOINT_MAIN=\"\1\"/g' "${ENV_FILE_FOR_BASH_GENERATED}"
	sed -i 's/^MAMBO_SERVICES_ENTRYPOINT_SECONDARY=\(.*\)$/MAMBO_SERVICES_ENTRYPOINT_SECONDARY=\"\1\"/g' "${ENV_FILE_FOR_BASH_GENERATED}"
	sed -i 's/^MAMBO_SERVICES_ENTRYPOINT_ADMIN=\(.*\)$/MAMBO_SERVICES_ENTRYPOINT_ADMIN=\"\1\"/g' "${ENV_FILE_FOR_BASH_GENERATED}"
	sed -i 's/^MAMBO_SERVICES_REDIRECT_HTTPS=\(.*\)$/MAMBO_SERVICES_REDIRECT_HTTPS=\"\1\"/g' "${ENV_FILE_FOR_BASH_GENERATED}"
	sed -i 's/^MAMBO_SERVICES_USE_LETS_ENCRYPT=\(.*\)$/MAMBO_SERVICES_USE_LETS_ENCRYPT=\"\1\"/g' "${ENV_FILE_FOR_BASH_GENERATED}"

	. "${ENV_FILE_FOR_BASH_GENERATED}"

}

# translate all relative path to absolute
# these path will overide variable defined in docker compse or env generated files because they are exported
__translate_all_path() {
	[ ! "${MAMBO_DATA_PATH}" = "" ] && export MAMBO_DATA_PATH="$($STELLA_API rel_to_abs_path "${MAMBO_DATA_PATH}" "${STELLA_APP_ROOT}")"
	[ ! "${MAMBO_DOWNLOAD_PATH}" = "" ] && export MAMBO_DOWNLOAD_PATH="$($STELLA_API rel_to_abs_path "${MAMBO_DOWNLOAD_PATH}" "${STELLA_APP_ROOT}")"
	[ ! "${PLEX_TRANSCODE_PATH}" = "" ] && export PLEX_TRANSCODE_PATH="$($STELLA_API rel_to_abs_path "${PLEX_TRANSCODE_PATH}" "${STELLA_APP_ROOT}")"
	
	__update_env_for_docker_compose "MAMBO_DATA_PATH"
	__update_env_for_docker_compose "MAMBO_DOWNLOAD_PATH"
	__update_env_for_docker_compose "PLEX_TRANSCODE_PATH"
	if [ ! "${MAMBO_MEDIA_FOLDERS}" = "" ]; then
		__tmp=
		for f in ${MAMBO_MEDIA_FOLDERS}; do
			f="$($STELLA_API rel_to_abs_path "${f}" "${STELLA_APP_ROOT}")"
			__tmp="${__tmp} ${f}"
		done
		export MAMBO_MEDIA_FOLDERS="$($STELLA_API trim "${__tmp}")"
		__update_env_for_docker_compose "MAMBO_MEDIA_FOLDERS"
	fi
}

# generate docker compose file
__set_docker_compose_file() {
	rm -f "${DOCKER_COMPOSE_FILE_GENERATED}"

	# copy original docker compose file
	cp -f "${DOCKER_COMPOSE_FILE_DEFAULT}" "${DOCKER_COMPOSE_FILE_GENERATED}"

	__set_time_all
	__set_entrypoints_service_all
	__set_redirect_https_service_all
	__add_service_direct_port_access_all
	__set_gpu_all
	__add_volume_media_all
	__set_letsencrypt_service_all
}




# MANAGE FEATURES FOR ALL CONTAINTERS -----------------

# add gpu to all container that need its
__set_gpu_all() {
	[ ! "${PLEX_HARDWARE_TRANSCODE}" = "" ] && __add_gpu "plex" "${PLEX_HARDWARE_TRANSCODE}"
}

# set timezone to containers which need it
__set_time_all() {
	if [ -f "/etc/timezone" ]; then
		TZ="$(cat /etc/timezone)"
		yq w -i "${DOCKER_COMPOSE_FILE_GENERATED}" "services.plex.environment[+]" "TZ=${TZ}"
	fi
	
	__add_volume_for_time "organizr2"
	__add_volume_for_time "ombi"
	__add_volume_for_time "sabnzbd"
	__add_volume_for_time "medusa"
	__add_volume_for_time "tautulli"
	__add_volume_for_time "traefik"
}



__set_letsencrypt_service_all() {
	for s in ${MAMBO_SERVICES_USE_LETS_ENCRYPT}; do
		__add_letsencrypt_service "${s}"
	done
}


__set_entrypoints_service_all() {
	for s in ${MAMBO_SERVICES_ENTRYPOINT_MAIN}; do
		__set_entrypoint_service "${s}"  "web_main"
	done
	for s in ${MAMBO_SERVICES_ENTRYPOINT_SECONDARY}; do
		__set_entrypoint_service "${s}"  "web_secondary"
	done
	for s in ${MAMBO_SERVICES_ENTRYPOINT_ADMIN}; do
		__set_entrypoint_service "${s}"  "web_admin"
	done
}

__set_redirect_https_service_all() {
	for s in ${MAMBO_SERVICES_REDIRECT_HTTPS}; do
		# look if on any entrypoint, we have to override the service router rule with the http-catchall rule
		for se in ${MAMBO_SERVICES_ENTRYPOINT_ADMIN}; do
			[ "${se}" = "${s}" ] && __set_redirect_https_service "${s}"  "web_admin"
		done
		for se in ${MAMBO_SERVICES_ENTRYPOINT_SECONDARY}; do
			[ "${se}" = "${s}" ] && __set_redirect_https_service "${s}"  "web_secondary"
		done
		for se in ${MAMBO_SERVICES_ENTRYPOINT_MAIN}; do
			[ "${se}" = "${s}" ] && __set_redirect_https_service "${s}"  "web_main"
		done
	done
}


__add_service_direct_port_access_all() {
	for service in $(compgen -A variable | grep _DIRECT_ACCESS_PORT); do
		port="${!service}"
		if [ ! "${port}" = "" ]; then
			service="${service%_DIRECT_ACCESS_PORT}"
			service="${service,,}"
			port_inside="$(yq r docker-compose.yml services.$service.expose[0])"
			if [ ! "${port_inside}" = "" ]; then
				[ "${VERBOSE}" = "1" ] && echo "* Activate direct access to $service : mapping $port to $port_inside"
				yq w -i "${DOCKER_COMPOSE_FILE_GENERATED}" "services.$service.ports[+]" "$port:$port_inside"
			else
				echo "* WARN : cannot activate direct access to $service through $port : Unknown inside port to map to. Inside port must be declared as first port in expose section."
			fi
		fi
	done
}


# add bind mount media volume mapped inside named volume /media
__add_volume_media_all() {
	for f in ${MAMBO_MEDIA_FOLDERS}; do
		f="$($STELLA_API rel_to_abs_path "${f}" "${STELLA_APP_ROOT}")"
		target="$(basename "${f}")"
		if [ -f "${f}" ]; then 
			echo "** [${f}] is a file, not mounted inside {/media}"
		else
			[ ! -d "${f}" ] && echo "** [${f}] is not an existing directory and will be auto created."
			__name="$($STELLA_API md5 "${f}")"
			__add_volume_local_definition "media_${__name}" "${f}"
			for s in $MAMBO_MEDIA_SERVICES; do
				__add_volume_mapping_service "${s}" "media_${__name}:/media/${target}"
			done
			[ "${VERBOSE}" = "1" ] && echo "** [${f}] will be mapped to {/media/${target}}"			
		fi
	done
}

# FEATURES MANAGEMENT --------
__add_gpu() {
	local __service="$1"
	local __opt="$2"

	__opt_intel_quicksync=0
	__opt_nvidia=0
	for o in $__opt; do
		[ "${o}" = "INTEL_QUICKSYNC" ] && __opt_intel_quicksync=1
		[ "${o}" = "NVIDIA" ] && __opt_nvidia=1
	done

	if [ "${__opt_intel_quicksync}" = "1" ]; then
		[ -d "/dev/dri" ] && yq w -i "${DOCKER_COMPOSE_FILE_GENERATED}" "services.${__service}.devices[+]" "/dev/dri:/dev/dri"
	fi

	if [ "${__opt_nvidia}" = "1" ]; then
		yq w -i "${DOCKER_COMPOSE_FILE_GENERATED}" "services.${__service}.environment[+]" "NVIDIA_VISIBLE_DEVICES=all"
		yq w -i "${DOCKER_COMPOSE_FILE_GENERATED}" "services.${__service}.environment[+]" "NVIDIA_DRIVER_CAPABILITIES=compute,video,utility"
		yq w -i "${DOCKER_COMPOSE_FILE_GENERATED}" "services.${__service}.runtime" "nvidia"
	fi
}

__add_volume_for_time() {
	local __service="$1"
	
	# create these volumes only if files exists
	[ -f "/etc/timezone" ] && __add_volume_mapping_service "${__service}" "/etc/timezone:/etc/timezone:ro"
	[ -f "/etc/localtime" ] && __add_volume_mapping_service "${__service}" "/etc/localtime:/etc/localtime:ro"
}


__add_letsencrypt_service() {
	local __service="$1"

	yq w -i "${DOCKER_COMPOSE_FILE_GENERATED}" "services.${__service}.labels[+]" "traefik.http.routers.${__service}-secure.tls.certresolver=mambo"
}

# declare an entrypoint to a service aswell to the secured version of the entrypoint
__set_entrypoint_service() {
	local __service="$1"
	local __entrypoint="$2"
	local __var="${__service^^}_ENTRYPOINTS"
	local __var_secure="${__service^^}_ENTRYPOINTS_SECURE"

	local __previous
	[ ! "${!__var}" = "" ] && __previous=",${!__var}"
	eval "export ${__var}=${__entrypoint}${__previous}"
	__update_env_for_docker_compose "${__var}"

	__previous=
	[ ! "${!__var_secure}" = "" ] && __previous=",${!__var_secure}"
	eval "export ${__var_secure}=${__entrypoint}_secure${__previous}"
	__update_env_for_docker_compose "${__var_secure}"
}

# change rule priority of a service to be overriden by the http-catchall rule
__set_redirect_https_service() {
	local __service="$1"
	
	__service="${__service^^}"
	local __var="${__service}_REDIRECT_HTTPS"

	eval "export ${__var}=50"
	__update_env_for_docker_compose "${__var}"

	# DEPRECATED : technique was to add a middleware redirect rule for each service
	# add only once ',' separator to compose file only if there is other middlewars declarated 
	# ex : "traefik.http.routers.sabnzbd.middlewares=${SABNZBD_REDIRECT_HTTPS}sabnzbd-stripprefix"
	# sed -i 's/\(.*\)\${'$__service'_REDIRECT_HTTPS}\([^,].\+\)\"$/\1\${'$__service'_REDIRECT_HTTPS},\2\"/g' "${DOCKER_COMPOSE_FILE_GENERATED}"

}

__add_volume_mapping_service() {
	local __service="$1"
	local __mapping="$2"

	yq w -i "${DOCKER_COMPOSE_FILE_GENERATED}" "services.${__service}.volumes[+]" "${__mapping}"

}

__add_volume_local_definition() {
	local __name="$1"
	local __path="$2"

	yq w -i "${DOCKER_COMPOSE_FILE_GENERATED}" "volumes.${__name}.driver" "local"
	yq w -i "${DOCKER_COMPOSE_FILE_GENERATED}" "volumes.${__name}.driver_opts.type" "none"
	yq w -i "${DOCKER_COMPOSE_FILE_GENERATED}" "volumes.${__name}.driver_opts.o" "bind"
	yq w -i "${DOCKER_COMPOSE_FILE_GENERATED}" "volumes.${__name}.driver_opts.device" "${__path}"
}





# PLEX -----------------

__init_service_plex() {
	# get claim token
	__claim_token=
	if [ "$(__is_plex_registered)" = "0" ]; then
		[ "${PLEX_USER}" = "" ] && echo "** Error missing plex user -- set PLEX_USER" && exit 1
		[ "${PLEX_PASSWORD}" = "" ] && echo "** Error missing plex password -- set PLEX_PASSWORD" && exit 1
		__auth_token="$(__get_plex_x_plex_token ${PLEX_USER} ${PLEX_PASSWORD})"
		echo " ** From plex.tv -- get auth token : ${__auth_token}"
		__claim_token="$(__get_plex_claim_token "${__auth_token}")"
		echo " ** From plex.tv -- get claim token : ${__claim_token}"
		if [ "${__claim_token}" = "" ]; then
			echo "** Error while getting claim token"
			exit 1
		fi
	else
		echo "** Plex service is already registred"
	fi
	# if plex was already be claimed, PLEX_CLAIM env var passed to plex is ignored
	export PLEX_CLAIM="${__claim_token}"
	__update_env_for_docker_compose "PLEX_CLAIM"

	# stop plex if it was already running
	docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" stop plex 
	# init plex
	docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" up -d plex
	# wait for conf and db files created
	sleep 4
	docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" stop plex
	sleep 4
	__set_plex_defaults
}

# test if plex was already claimed
__is_plex_registered() {
	PLEX_PREFERENCES_PATH="${MAMBO_DATA_PATH}/plex/Library/Application Support/Plex Media Server/Preferences.xml"
	[ -f "${PLEX_PREFERENCES_PATH}" ] && __online_token="$(__xml_get_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences/@PlexOnlineToken")"

	[ ${#__online_token} -gt 0 ] && echo "1" || echo "0"
}

# get a plex auth token
__get_plex_x_plex_token() {
	local __login="$1"
	local __password="$2"

	__auth_token="$(curl -kLsu "${__login}":"${__password}" -X POST "https://plex.tv/users/sign_in.json" \
	-H "X-Plex-Version: 1.0.0" \
	-H "X-Plex-Product: Mambo" \
	-H "X-Plex-Client-Identifier: Mambo-$(__generate_machine_id)" \
	-H "Content-Type: application/x-www-form-urlencoded; charset=utf-8" | jq -r .user.authentication_token)"

	[ "${__auth_token}" = "null" ] && echo "" || echo "${__auth_token}"
}

# get plex claim token
__get_plex_claim_token() {
	local __x_plex_token="$1"

	__clam_token="$(curl -kLs -X GET "https://plex.tv/api/claim/token.json" \
		-H "X-Plex-Version: 1.0.0" \
		-H "X-Plex-Product: Mambo" \
		-H "X-Plex-Client-Identifier: Mambo-$(__generate_machine_id)" \
		-H "X-Plex-Token: ${__x_plex_token}" \
		-H "Content-Type: application/x-www-form-urlencoded; charset=utf-8" | jq -r .token)"


	[ "${__clam_token}" = "null" ] && echo "" || echo "${__clam_token}"

}


__set_plex_defaults() {
	PLEX_PREFERENCES_PATH="${MAMBO_DATA_PATH}/plex/Library/Application Support/Plex Media Server/Preferences.xml"
	
	
	if [ -f "${PLEX_PREFERENCES_PATH}" ]; then 
		# transcode folder to store temp files
		__xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "TranscoderTempDirectory" "/transcode"

		# 'forceAutoAdjustQuality' in Preferences.xml
		# Force clients to use automatic quality for media unless the quality is set higher than the quality of the video.
		# ex: quality set to 4mbps; watching >4mbps will trigger auto quality mode)
		# ex: quality set to original/max; auto quality will never be used & you will always be streaming at the video's original bitrate
		# default : 0
		__xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "forceAutoAdjustQuality" "${PLEX_CLIENT_FORCE_AUTO_QUALITY}"

		# 'AllowHighOutputBitrates' in Preferences.xml
		# Force transcode quality to upscale. But can cause high bandwidth usage for clients.
		# default : 0
		__xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "AllowHighOutputBitrates" "${PLEX_CLIENT_FORCE_TRANSCODE_UPSCALE}"

		# 'GdmEnabled' in Preferences.xml
		# This enables the media server to discover other servers and players on the local network.
		__xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "GdmEnabled" "0"

		# 'TranscoderThrottleBuffer' in Preferences.xml
		# Amount in seconds to buffer before throttling the transcoder.
		# default : 60
		__xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "TranscoderThrottleBuffer" "${PLEX_TRANSCODER_THROTTLE_BUFFER}"

		# ManualPortMappingMode="1" in Preferences.xml
		# default : 0
		# 'ManualPortMappingPort' in Preferences.xml
		# Manually specify public port. You may need to enable this to establish a direct connection from outside your network.
		# default : empty
		__xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "ManualPortMappingMode" "1"
		__xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "ManualPortMappingPort" "${MAMBO_PORT_MAIN}"

		#  TODO  secureConnections="1" customCertificateDomain="https://iron.studio-etrange.podzone.net:32400" customCertificateKey="mambo" customCertificatePath=" /var/lib/plexmediaserver/certificate.pfx"


		# 'DlnaEnabled' in Preferences.xml
		__xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "DlnaEnabled" "0"
		
		# collectUsageData in Preferences.xml
		# sendCrashReports in Preferences.xml
		__xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "collectUsageData" "0"
		__xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "sendCrashReports" "0"

		# secureConnections in Preferences.xml
		# 0 : Required
		# 1 : Preferred
		# 2 : Disabled
		__xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "secureConnections" "${PLEX_HTTPS_MODE}"


		# activate hardware transcoding
		[ ! "${PLEX_HARDWARE_TRANSCODE}" = "" ] && __xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "HardwareAcceleratedCodecs" "1" \
												|| __xml_set_attribute_value "${PLEX_PREFERENCES_PATH}" "/Preferences" "Preferences" "HardwareAcceleratedCodecs" "0" \

	fi

	# optimize plex db
	[ ! "${PLEX_DB_CACHE_SIZE}" = "" ] && __set_plex_db_cache_size "${PLEX_DB_CACHE_SIZE}"

}



# optimize plex db
# could ameliorate some result
# https://github.com/Cloudbox/Cloudbox/blob/master/roles/plex/tasks/subtasks/settings/db_cache_size.yml
# https://forums.plex.tv/t/plex-library-performance-tip/176195/10
__set_plex_db_cache_size() {
	if [ ! "$1" = "" ]; then
		PLEX_DATABASE_SUBPATH="Library/Application Support/Plex Media Server/Plug-in Support/Databases/com.plexapp.plugins.library.db"
		# set default_cache_size
		if [ -f "${MAMBO_DATA_PATH}/plex/${PLEX_DATABASE_SUBPATH}" ]; then

			docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" stop plex

			echo "** Actual plex db default_cache_size :"
			docker run --rm -v "${MAMBO_DATA_PATH}/plex:/data" nouchka/sqlite3 "/data/${PLEX_DATABASE_SUBPATH}" "PRAGMA default_cache_size;"
			echo "** Set plex db default_cache_size to $1"
			docker run --rm -v "${MAMBO_DATA_PATH}/plex:/data" nouchka/sqlite3 "/data/${PLEX_DATABASE_SUBPATH}" "PRAGMA default_cache_size=$1;"
			echo "** Actual plex db default_cache_size :"
			docker run --rm -v "${MAMBO_DATA_PATH}/plex:/data" nouchka/sqlite3 "/data/${PLEX_DATABASE_SUBPATH}" "PRAGMA default_cache_size;"
		else
			echo "[${MAMBO_DATA_PATH}/plex/${PLEX_DATABASE_SUBPATH}] do not exist"
			echo "Plex database do not exist yet, launch at least once plex."
		fi
	fi
}



# VARIOUS -----------------
# set an attribute value of a node selected by an xpath expression
# 	__xml_replace_attribute_value "Preferences.xml" "/Preferences" "Preferences" "TranscoderTempDirectory" "/transode"
# 	xidel Preferences.xml --silent --xml --xquery3 'let $selected := /Preferences return transform(/,function($e) { if ($selected[$e is .]) then <Preferences>{$e/attribute() except $e/@TranscoderTempDirectory, attribute TranscoderTempDirectory { "/transcode" },$e/node()}</Preferences> else $e })'
# http://x-query.com/pipermail/talk/2013-December/004266.html
__xml_set_attribute_value() {
	local __file="$1"
	local __xpath_selector="$2"
	local __node_name="$3"
	local __attribute_name="$4"
	local __attribute_value="$5"


	xidel "${__file}" --silent --xml --xquery3 'let $selected := '${__xpath_selector}' return transform(/,function($e) { if ($selected[$e is .]) then <'${__node_name}'>{$e/attribute() except $e/@'${__attribute_name}', attribute '${__attribute_name}' { "'${__attribute_value}'" },$e/node()}</'${__node_name}'> else $e })' > "${__file}.new"
	rm -f "${__file}"
	mv "${__file}.new" "${__file}"
}

__xml_get_attribute_value() {
	local __file="$1"
	local __xpath_selector="$2"

	xidel "${__file}" --silent --extract "${__xpath_selector}"
}


# Mambo mandatory root path
__set_mandatory_root_path_to_default() {
	if [ "${MAMBO_DATA_PATH}" = "" ]; then
	 	export MAMBO_DATA_PATH="${STELLA_APP_WORK_ROOT}/data"
		 __update_env_for_docker_compose "MAMBO_DATA_PATH"
		 # TODO 1 chown ${MAMBO_USER_ID}:${MAMBO_GROUP_ID} "${MAMBO_DATA_PATH}" ? if exists ? or do it in service_init ?
		 # TODO 2 create dir in all cases ? not only in case we are using default values
		docker run -it --rm -v "${STELLA_APP_WORK_ROOT}":"${STELLA_APP_WORK_ROOT}" bash:4.4.23 bash -c "mkdir -p "${MAMBO_DATA_PATH}" && chown ${MAMBO_USER_ID}:${MAMBO_GROUP_ID} "${MAMBO_DATA_PATH}""
	fi
	if [ "${MAMBO_DOWNLOAD_PATH}" = "" ]; then
	 	export MAMBO_DOWNLOAD_PATH="${STELLA_APP_WORK_ROOT}/download"
		__update_env_for_docker_compose "MAMBO_DOWNLOAD_PATH"
		docker run -it --rm -v "${STELLA_APP_WORK_ROOT}":"${STELLA_APP_WORK_ROOT}" bash:4.4.23 bash -c "mkdir -p "${MAMBO_DOWNLOAD_PATH}" && chown ${MAMBO_USER_ID}:${MAMBO_GROUP_ID} "${MAMBO_DOWNLOAD_PATH}""
	fi
}


# test if mandatory root path exists
__check_mandatory_root_path() {
	[ ! -d "${MAMBO_DATA_PATH}" ] && echo "* ERROR : Mandatory data root path [${MAMBO_DATA_PATH}] do not exist" && exit 1
	[ ! -d "${MAMBO_DOWNLOAD_PATH}" ] && echo "* ERROR : Mandatory download root path [${MAMBO_DOWNLOAD_PATH}] do not exist" && exit 1
	if [ "${MAMBO_MEDIA_FOLDERS}" = "" ]; then
		echo "* WARN : There is no media folders defined"
	else
		for f in ${MAMBO_MEDIA_FOLDERS}; do
			[ ! -d "${f}" ] && echo "* ERROR : Mandatory declared media folder [${f}] do not exist" && exit 1
		done
	fi


}



usage() {
	echo "USAGE :"
	echo "----------------"
	echo "o-- general management :"
	echo "L     install : deploy this app"
	echo "L     up [service [-d]] : launch all mambo services or one service"
	echo "L     down [service] : down all mambo services or one service"
	echo "L     restart [service [-d]] : restart all mambo services or one service"
	echo "L     info : give info on Mambo. Will generate conf files and print configuration used when launching any service."
	echo "L     status [service] : see status"
	echo "L     logs [service] : see logs"
	echo "L     shell <service> : launch a shell into a running service"
	echo "L     init : init services. Do it once before launch. - will stop plex"
}

# COMMAND LINE -----------------------------------------------------------------------------------
PARAMETERS="
DOMAIN=											'action' 			a				'info shell up down status install logs init restart' '1'
TARGET=												'target' 					a				'${MAMBO_SERVICES_LIST}'	'0'
"
OPTIONS="
FILE='${ENV_FILE_USER}'				  		'f'				'path'					s			0		''					  User env site file (example : HOME/mambo.env).
DAEMON=''				    'd'				''						b			0		''					  Daemon mode. When launching whole mambo, it is in daemon mode by default, but when launching a specific service, launch it in daemon mode.
VERBOSE=''				    'v'				''						b			0		''					  Verbose mode for debug purpose.
PUID='$(id -u)' 			'u' 			'string'				s 			0			''		  user id - set MAMBO_USER_ID variable - will own bind mount created folder/files.
PGID='$(id -g)' 			'g' 			'string'				s 			0			''		  group id - set MAMBO_GROUP_ID variable - will own bind mount created folder/files.
"
$STELLA_API argparse "$0" "$OPTIONS" "$PARAMETERS" "$STELLA_APP_NAME" "$(usage)" "EXTRA_PARAMETER ARG" "$@"

#-------------------------------------------------------------------------------------------
ENV_FILE_USER="$($STELLA_API rel_to_abs_path "${FILE}" "${_CURRENT_RUNNING_DIR}")"

# check if mambo have been installed and generate all conf files
type docker-compose 1>/dev/null 2>&1 && {
	__manage_env_and_files
}



# set environment variables from command line
[ "${MAMBO_USER_ID}" = "" ] && export MAMBO_USER_ID="${PUID}" \
								|| export MAMBO_USER_ID="${MAMBO_USER_ID}"

[ "${MAMBO_GROUP_ID}" = "" ] && export MAMBO_GROUP_ID="${PGID}" \
								|| export MAMBO_GROUP_ID="${MAMBO_GROUP_ID}"

__update_env_for_docker_compose "MAMBO_USER_ID"
__update_env_for_docker_compose "MAMBO_GROUP_ID"

[ "${DAEMON}" = "1" ] && DAEMON="-d"

case $DOMAIN in
	install )
		;;
	* )
		__set_mandatory_root_path_to_default
		__check_mandatory_root_path
		;;
esac


# ------------- ENV ----------------------------


case $DOMAIN in
	install )
		echo "** Install requirements"
		$STELLA_API get_features
	;;

	shell )
		if [ "${TARGET}" = "" ]; then
			echo "** ERROR : specify a running service in which you want a shell access"
			exit 1
		else
			docker exec -it "mambo_${TARGET}" /bin/sh -c "[ -e /bin/bash ] && /bin/bash || /bin/sh"
		fi
	;;

	init )
		echo "** Init service Plex"
		__init_service_plex
	;;

	info )
		docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" up service_init
	;;

	up )
		docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" up ${DAEMON} ${TARGET:-mambo}
		if [ "${DAEMON}" = "" ]; then
			[ "${TARGET}" = "" ] && docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" logs service_init
		else
			docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" logs service_init
		fi
	;;

	down )
		case "${TARGET}" in
		"") 
			docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" down -v 
		;;
		*) 
			docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" stop ${TARGET}
		;;
		esac
	;;

	restart )
		case "${TARGET}" in
		"") 
			docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" down -v 
		;;
		*) 
			docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" stop ${TARGET}
		;;
		esac
		docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" up ${DAEMON} ${TARGET:-mambo}
		if [ "${DAEMON}" = "" ]; then
			[ "${TARGET}" = "" ] && docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" logs service_init
		else
			docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" logs service_init
		fi

	;;

	status )
		docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" ps ${TARGET}
	;;

	logs )
		docker-compose -f "${DOCKER_COMPOSE_FILE_GENERATED}" logs -t ${TARGET}
	;;
esac


